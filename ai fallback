import re, spacy
from typing import List, Tuple, Optional, Dict

try:
    NLP = spacy.load("en_core_web_sm")
except Exception:
    NLP = spacy.blank("en")

RE_DATE = re.compile(r"\b\d{4}-\d{2}-\d{2}\b|\b\d{2}[-/]\d{2}[-/]\d{4}\b")
RE_PERCENT = re.compile(r"-?\d+(?:\.\d+)?\s*%|-?\d+(?:\.\d+)?\s*percent", re.I)
RE_AMOUNT = re.compile(r"\b([A-Z]{3})\s?\d{1,3}(?:,\d{3})*(?:\.\d+)?\b|\b\d{1,3}(?:,\d{3})*(?:\.\d+)?\s?([A-Z]{3})\b")
RE_CCY = re.compile(r"\b[A-Z]{3}\b")

ANCHORS: Dict[str, List[str]] = {
    "business_date": ["business date","cob","cob date"],
    "trade_date": ["trade date"],
    "settlement_date": ["settlement date","value date"],
    "market_rate_datetime": ["market rate time","rate timestamp","market timestamp"],
    "legal_entity": ["legal entity","le"],
    "counterparty_acronym": ["counterparty","cp","cpty"],
    "book": ["book","fxcashbook"],
    "region_code": ["region"],
    "timezone": ["time zone","timezone"],
    "source_system": ["source system"],
    "originating_system": ["originating system"],
    "pnl_amount": ["pnl","profit","p&l"],
    "commission_amount": ["commission"],
    "commission_ccy": ["commission ccy"],
    "pnl_ccy": ["pnl ccy"],
    "base_currency_cd": ["base currency"],
    "orig_currency_cd": ["originating currency","orig currency"],
    "deviation_percent": ["deviation","deviation percent"],
    "base_threshold_percent": ["base threshold"],
    "orig_threshold_percent": ["original threshold","orig threshold"],
    "execution_key": ["execution key"],
    "trade_id": ["trade id","tradeid"],
    "efx_trade_id": ["efx trade id","efx id"],
    "representative_key": ["representative key"],
    "record_type": ["record type"],
    "trade_type": ["trade type"],
    "alert_description": ["alert description","alert","reason"],
    "hms_book_guid": ["hms book guid"],
    "bui_value": ["bui value"],
    "notional_range": ["notional range"],
    "tenor": ["tenor"],
}

LABEL_PREFS: Dict[str, List[str]] = {
    "business_date": ["DATE"], "trade_date": ["DATE"], "settlement_date": ["DATE"],
    "market_rate_datetime": ["DATE","TIME"],
    "legal_entity": ["ORG"], "counterparty_acronym": ["ORG","PERSON"],
    "region_code": ["GPE","LOC"],
    "pnl_amount": ["MONEY","CARDINAL"], "commission_amount": ["MONEY","CARDINAL"],
    "deviation_percent": ["PERCENT"],
}

def _spans(rx, text): return [(m.start(), m.end(), m.group(0)) for m in rx.finditer(text)]

def _collect(doc, field, text):
    cands = []
    if hasattr(doc, "ents"):
        for ent in doc.ents:
            allow = LABEL_PREFS.get(field, [])
            if not allow or ent.label_ in allow:
                cands.append((ent.start_char, ent.end_char, ent.text))
    if "date" in field: cands += _spans(RE_DATE, text)
    if "percent" in field: cands += _spans(RE_PERCENT, text)
    if "amount" in field or "notional" in field: cands += _spans(RE_AMOUNT, text)
    if field.endswith("_ccy") or field.endswith("_currency_cd"): cands += _spans(RE_CCY, text)
    seen, out = set(), []
    for s,e,t in cands:
        if (s,e) in seen: continue
        seen.add((s,e)); out.append((s,e,t))
    return out

def _anchors_positions(text, anchors):
    pos, low = [], text.lower()
    for a in anchors:
        start = 0; a = a.lower()
        while True:
            i = low.find(a, start)
            if i < 0: break
            pos.append(i); start = i+len(a)
    return pos

def _score(anchor_pos, span):
    if not anchor_pos: return 0.60
    s,_ = span
    d = min(abs(s - ap) for ap in anchor_pos)
    return max(0.6, min(0.9, 0.9 - d/500.0))

def call_mrc_model(context: str, field: str):
    anchors = ANCHORS.get(field, [field.replace("_", " ")])
    doc = NLP(context)
    cands = _collect(doc, field, context)
    if not cands: return None, 0.0, (0,0), False
    aps = _anchors_positions(context, anchors)
    best, best_score = None, -1
    for s,e,t in cands:
        sc = _score(aps, (s,e))
        if "percent" in field and RE_PERCENT.fullmatch(t.strip()): sc += 0.05
        if ("amount" in field or "notional" in field) and RE_AMOUNT.fullmatch(t.strip()): sc += 0.05
        if "date" in field and RE_DATE.fullmatch(t.strip()): sc += 0.05
        if sc > best_score:
            best, best_score = (t, sc, (s,e)), sc
    value, conf, span = best
    return value, conf, span, bool(aps)

def run_ai_fallback(text: str, fields: List[str]):
    out = {}
    for f in fields:
        val, conf, span, has_anchor = call_mrc_model(text, f)
        if not val: continue
        out[f] = [{
            "value": val, "raw": val, "span": span,
            "confidence": round(conf, 3),
            "method": "ai_anchor" if has_anchor else "ai_no_anchor",
            "source": "TXT", "snippet": text[max(0,span[0]-40):min(len(text), span[1]+40)]
        }]
    return out
