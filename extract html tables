def table_rows_to_text(table_rows):
    """
    table_rows: list[list[str]], where table_rows[0] = headers, the rest = rows
    Returns a single text block: "Header: Value, Header2: Value2" per row.
    """
    if not table_rows:
        return ""

    headers = [str(h).strip() for h in table_rows[0]]
    lines = []
    for r in table_rows[1:]:
        row = [str(x).strip() for x in r]
        # pad/truncate to header length
        if len(row) < len(headers):
            row += [""] * (len(headers) - len(row))
        elif len(row) > len(headers):
            row = row[:len(headers)]
        # zip to dict, drop empties
        pairs = [f"{h}: {v}" for h, v in zip(headers, row) if v]
        if pairs:
            lines.append(", ".join(pairs))
    return "\n".join(lines)

# If you might have multiple tables:
def all_tables_to_text(html_tables):
    """
    html_tables can be:
      - one table: [headers, row1, row2...]
      - many tables: [[headers,...],[...], ...]
    Returns merged text for all tables.
    """
    # Detect “list of tables” vs single table
    is_single = html_tables and all(isinstance(c, str) for c in html_tables[0])
    tables = [html_tables] if is_single else html_tables

    blocks = []
    for tbl in tables:
        blocks.append(table_rows_to_text(tbl))
    return "\n".join(b for b in blocks if b)

# Usage with your current output:
text_for_matching = all_tables_to_text(html_tables)
