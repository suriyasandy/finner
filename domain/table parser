from bs4 import BeautifulSoup
import re

def _clean_html_for_msg(html):
    if not html:
        return ""
    if isinstance(html, bytes):
        try:
            html = html.decode("utf-8", errors="ignore")
        except Exception:
            html = html.decode("latin-1", errors="ignore")
    html = re.sub(r'<!--\[if.*?endif\]-->', '', html, flags=re.DOTALL|re.IGNORECASE)
    html = re.sub(r'<xml>.*?</xml>', '', html, flags=re.DOTALL|re.IGNORECASE)
    html = re.sub(r'<br\s*/?>', ' ', html, flags=re.IGNORECASE)
    return html

def _cell_text(tag) -> str:
    txt = tag.get_text(" ", strip=True)
    txt = re.sub(r'\xa0', ' ', txt)
    txt = re.sub(r'\s+', ' ', txt).strip()
    return txt

def _looks_like_label(s: str) -> bool:
    if not s: return False
    s = s.strip()
    # Heuristic: short-ish, mostly words/symbols we see in headers, or ends with colon
    return s.endswith(":") or (len(s) <= 40 and re.match(r'^[A-Za-z][A-Za-z0-9 _/().%-]*$', s) is not None)

def _expand_grid(table):
    """
    Build a 2D grid of cell texts, expanding colspan/rowspan.
    Returns: grid (list of rows), has_th (bool if any header cells present)
    """
    rows = table.find_all("tr")
    grid = []
    has_th = False
    # Keep track of occupied cells due to rowspans
    row_spans = {}
    for r_idx, tr in enumerate(rows):
        cols = tr.find_all(["td", "th"])
        c_idx = 0
        row_cells = []
        # apply pending rowspans
        while row_spans.get((r_idx, c_idx)):
            row_cells.append(row_spans[(r_idx, c_idx)])
            c_idx += 1

        for cell in cols:
            text = _cell_text(cell)
            if cell.name.lower() == "th":
                has_th = True
            colspan = int(cell.get("colspan", "1") or 1)
            rowspan = int(cell.get("rowspan", "1") or 1)

            # place this cell at first free column
            while row_spans.get((r_idx, c_idx)):
                row_cells.append(row_spans[(r_idx, c_idx)])
                c_idx += 1

            row_cells.append(text)
            # fill colspans in current row with placeholders (we'll treat as same cell)
            for k in range(1, colspan):
                row_cells.append(text)
            # record rowspans to apply in subsequent rows
            if rowspan > 1:
                for rr in range(1, rowspan):
                    for cc in range(colspan):
                        row_spans[(r_idx + rr, c_idx + cc)] = text
            c_idx += colspan

        grid.append(row_cells)

    # normalize row lengths
    max_w = max((len(r) for r in grid), default=0)
    for r in grid:
        if len(r) < max_w:
            r += [""] * (max_w - len(r))
    return grid, has_th

def _best_header_row_index(grid):
    """
    Choose the row index that looks most like a header row.
    Returns index or None.
    """
    best_idx, best_score = None, 0.0
    for i, row in enumerate(grid):
        if not any(row):  # empty row
            continue
        labels = sum(1 for x in row if _looks_like_label(x))
        filled = sum(1 for x in row if x.strip() != "")
        if filled == 0:
            continue
        score = labels / max(1, filled)
        # prefer earlier rows slightly
        score_adj = score - 0.02 * i
        if score_adj > best_score and score >= 0.5:  # at least half look like labels
            best_score, best_idx = score_adj, i
    return best_idx

def _first_nonempty_to_right(row, start_col=1):
    for j in range(start_col, len(row)):
        v = row[j].strip()
        if v:
            return v
    return ""

def extract_html_tables_as_text_from_html(html_body: str) -> str:
    if not html_body:
        return ""
    html = _clean_html_for_msg(html_body)
    soup = BeautifulSoup(html, "html.parser")

    lines = []
    for table in soup.find_all("table"):
        grid, has_th = _expand_grid(table)
        if not grid:
            continue

        # Heuristic 1: classic vertical KV (labels in first col)
        first_col = [r[0].strip() for r in grid if len(r) > 0]
        labelish_ratio = 0.0
        if first_col:
            labelish_ratio = sum(1 for x in first_col if _looks_like_label(x)) / len(first_col)

        if labelish_ratio >= 0.6:
            # treat as vertical KV: key = first col (strip colon), value = first non-empty cell to the right
            for r in grid:
                if not r: 
                    continue
                k = (r[0] or "").strip()
                if not _looks_like_label(k):
                    continue
                v = _first_nonempty_to_right(r, start_col=1)
                if not v:
                    continue
                if k.endswith(":"): k = k[:-1].strip()
                lines.append(f"{k}: {v}")
            continue

        # Heuristic 2: header row across the top (any row with many label-like cells)
        hdr_idx = _best_header_row_index(grid)
        if hdr_idx is not None:
            headers = [ (h[:-1].strip() if h.endswith(":") else h.strip()) for h in grid[hdr_idx] ]
            # drop empty headers
            headers = [h if h else "" for h in headers]
            # emit rows below header
            for r in grid[hdr_idx+1:]:
                kv = []
                for h, v in zip(headers, r):
                    v = (v or "").strip()
                    if not h or not v:
                        continue
                    if _looks_like_label(h):
                        kv.append(f"{h}: {v}")
                if kv:
                    lines.append(", ".join(kv))
            continue

        # Heuristic 3: fallback — try two-column KV if table width==2
        width = max(len(r) for r in grid)
        if width == 2:
            for r in grid:
                if len(r) < 2: 
                    continue
                k = (r[0] or "").strip()
                v = (r[1] or "").strip()
                if not k or not v:
                    continue
                if k.endswith(":"): k = k[:-1].strip()
                if _looks_like_label(k):
                    lines.append(f"{k}: {v}")
            continue

        # Heuristic 4: very last resort — skip generic COL/Unnamed; only output header:value where header looks like a label
        for r in grid:
            # treat r[0] as potential label if nothing else found
            if len(r) >= 2 and _looks_like_label(r[0]) and r[1].strip():
                k = r[0][:-1].strip() if r[0].endswith(":") else r[0].strip()
                lines.append(f"{k}: {r[1].strip()}")

    return "\n".join(lines)
