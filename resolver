# resolver.py
from typing import Dict, List

# Base weights by method
BASE = {
    "gazetteer_exact": 0.95,
    "regex_strong":    0.90,
    "gazetteer_fuzzy": 0.85,   # actual will vary with fuzzy score
    "ai_anchor":       0.75,
    "ai_no_anchor":    0.60,
}

def _state(score: float) -> str:
    if score >= 0.90: return "auto_accept"
    if score >= 0.70: return "needs_review"
    return "likely_wrong"

def _clamp(x: float, lo=0.0, hi=1.0) -> float:
    return max(lo, min(hi, x))

def resolve_candidates(candidates: Dict[str, List[dict]]) -> Dict[str, dict]:
    """
    candidates[field] = [
      {value, method, conf, source, snippet, span, extras}
    ]
    Returns fields[field] = {value, final_confidence, state, method, evidence, alternates}
    """
    results = {}
    for field, cands in candidates.items():
        if not cands:
            continue

        # Cross-source agreement boost: +0.05 if same value appears >=2 times
        value_counts = {}
        for c in cands:
            value_counts[c["value"]] = value_counts.get(c["value"], 0) + 1
        for c in cands:
            boost = 0.05 if value_counts.get(c["value"], 0) >= 2 else 0.0
            c["conf"] = _clamp(c["conf"] + boost)

        # Pick best
        best = max(cands, key=lambda x: x["conf"])

        results[field] = {
            "value": best["value"],
            "final_confidence": round(best["conf"], 3),
            "state": _state(best["conf"]),
            "method": best["method"],
            "evidence": cands,
            "alternates": sorted(
                [c for c in cands if c is not best],
                key=lambda x: x["conf"], reverse=True
            )[:5]
        }
    return results
